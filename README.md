# Практикум 1
## Запуск тестов
```
$ pytest test.py
```

## Алгоритм
Назовем состоянием строки -- пару (int, bool), где число показывает кол-во необходимых букв в начале строки, а флаг говорит если данная строка заканчивается на необходимый символ, т.е. значение True, если заканчивается на данный символ и False, если на другой. Тогда буквы из алфавита, которые не требуемые будут состояния -- (0, False), требуемая буква -- (1, True), 1 -- (0, True). При обработки операций, в частности + и * может возникать неоднозначность, т.к. возникает ветвлений возможных состояний, будем хранить два состояния, одно -- с максимальным числом и флагом False, другое -- с масимальным числом и флагом True. При выполнении операции \*, если строка над которой совершают операцию с флагом True, при этом число ненулевое, то состояние после операции (inf, True), т.к. в начале может быть сколько угодно требуемых символов, если значение 0, то это просто пустое слово, состояние после операции -- (0, True), если изначальный флаг False, то у получившейся строки состояние будет (0, True) пустая строка и начальное состояние, т.к. при любом кол-ве умножений состояние не изменится. При выполнении операции + просто найдем максимум по значениям с каждым из возможных флагов -- это и будет набор состояний. При выполнении операции . важен порядок аргументов. Очевидно, что состояние с флагом True можно получить единственным способом из первого аргумента и его состояния с данным флагом и второго аргумента с его состоянием, т.к. строка, которая состоит только из данного символа получается конкатенацией только строк из данного символа. Состояние с флагом False получается либо из состояния с флагом True из первого аргумента и с флагом False из второго, либо из состояния с флагом False из второго, достаточно просто найти максимум из их значений. По итогу должен получиться одно множество из двух состояний, где ответ на задачу будет максимум из двух состояний.

Асимптотика будет O(|n|), где n -- длина регулярного выражения в обратной польской записи, т.к. каждый символ обрабатывается не более чем за константу.

## Реализация
Заведем стек (deque из collections, в котором будем использовать добавление только с одной стороны), в котором будем хранить dict'ы с ключами with_last, without_last, где первое -- состояние с максимальным значением в котором флаг True, второе соответственно с флагом False, возможно пустое состояние по какому-то ключу. Далее будем идти последовательно по выражению, если встречаем букву, то пушим на стек dict из одного состояния в зависимости от буквы (как написано в алгоритме), если оператор, то в зависимости от арности, достаем со стека один или два последних dict'а с состояниями, обрабатываем как описано в алгоритме, получившееся множество с состояниями пушим на стек. Если в какой-то момент стек меньше чем арность оператора, то выбрасываем ошибку. В итоге должно остаться единственное состояние, если после всех операций на стеке количество элементов не равно 1, то  опять выбрасываем ошибку, если же там один dict, просто найдем максимум из тех двух значений.

