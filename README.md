# Практикум 1
## Условие задачи
Даны регулярное выражение `a` и буква `x`. Найти максимальное `k`, такое что в `L` есть слова, начинающиеся с `x^k`.

## Запуск тестов
```
$ pip install pytest
$ pytest test.py
```

## Алгоритм

Назовем состоянием строки набор пар вида `(int, bool)`, где `int` будет число `x` в начале, а `bool` будет `False`, если между концом строки и началом есть не `x`, `True` иначе, т.е. строки вида `aaabacaa`, `bbaa`, `aa` будут `(3, False)`, `(0, False)`, `(2, True)` соответственно. При этом будем хранить в наборе не более двух состояний, где одно с максимальным возможным значением `int`, а `bool` есть `False`, аналогично второе, только для `bool`'а значение `True`. Большее кол-во состояний будет излишним, т.к. любое другое состояние будет иметь уже один существующий флаг, но меньше значение `x` в начале, но по условию требуется максимум.

* Инициализируем пустой стек.
* Рассмотрим текущий элемент из входящего регулярного выражения `a`.
  * Если это буква, то в стек добавим состояние `(1, True)` для `a == x`, `(0, False)` для `a` отличной от `x`, но не равной 1, для 1 добавим `(0, True)`.
  * Если это `.`, то достанем два последовательных элемента из стека (т.е. набора пар). Хотим получить два новых состояния. Т.к. операция -- конкатенация, то если мы конкатенируем любую строку с другой строкой с `bool` состояния `False`, то ответ будет иметь `bool` состояния `False`, т.к. в слагаемых были буквы не `x`, то в итоге они тоже останутся, если конкатенируем две строки с `bool` состояния `True`, то только в таком случае результат будет с состоянием `True`, если первое слагаемое будет иметь `bool` равный `False`, то результирующее состояние будет в точности равно первому слагаемому. Далее просто проверим на максимальность получаемых значений с различными флагами и добавим в стек результирующее состояние.
  * Если это `+`, то достанем два последовательных элемента из стека, сравним значения с разными флагами, возьмем максимум по каждому. Это и будет новым состоянием.
  * Если это `*`, то достанем последний элемент из стека, посмотрим если есть пара вида `(n, True)`, где `n > 0`, то в таком случае новое состояние будет `(inf, True)`, т.к. данных букв может быть любое кол-во, если есть пара `(n, False)`, то она такой и останется, т.к. при добавлении любого кол-ва строк к строке с `bool` состояния `False` значение не изменится, если `n = 0` или состояния с `True` нет, то добавим `(0, True)`, т.е. пустое слово.
 * Если в какой-то момент для операции недостаточно аргументов, то надо вывести `ERROR`.
 * Повторим это для каждого элемента из выражения.
 * После обработки всего выражения в стеке должен остаться один элемент, если кол-во элементов не равно одному, то надо вывести `ERROR`. Иначе надо просто найти максимум по значениям в парах из состояний, это и будет ответом.

Асимптотика будет O(|n|), где n -- длина регулярного выражения в обратной польской записи, т.к. каждый символ из выражения обрабатывается не более чем за константу.

## Реализация
Заведем стек (deque из collections, в котором будем использовать добавление только с одной стороны), в котором будем хранить dict'ы с ключами with_last, without_last, где первое -- пара с максимальным значением в котором флаг True, второе соответственно с флагом False, возможно пустое состояние по какому-то ключу. Далее будем идти последовательно по выражению, если встречаем букву, то пушим на стек dict из одного состояния в зависимости от буквы (как написано в алгоритме), если оператор, то в зависимости от арности, достаем со стека один или два последних dict'а с состояниями, обрабатываем как описано в алгоритме, получившееся множество с состояниями пушим на стек. Если в какой-то момент стек меньше чем арность оператора, то выбрасываем ошибку. В итоге должно остаться единственное состояние, если после всех операций на стеке количество элементов не равно 1, то  опять выбрасываем ошибку, если же там один dict, просто найдем максимум из пар по значениям.
